// === Program Structure ===
program = { SOI ~ statement* ~ EOI }
statement = { struct_decl | tool_decl | agent_decl | top_level_let }

// === Top-Level Let ===
top_level_let = { "let" ~ identifier ~ "=" ~ expression }

// === Tool Declaration ===
tool_decl = {
    "tool" ~ identifier ~ "(" ~ param_list? ~ ")" ~ return_type? ~ block
}
param_list = { param ~ ("," ~ param)* }
param = { identifier ~ ":" ~ type_name }
return_type = { "->" ~ type_name }
type_name = { "string" | "number" | "boolean" | "object" | "array" | "any" }

// === Struct Declaration ===
struct_decl = {
    "struct" ~ identifier ~ "{" ~ struct_body ~ "}"
}
struct_body = { (struct_field ~ ","?)* }
struct_field = { identifier ~ ":" ~ field_type }
field_type = {
    field_type_array |
    field_type_object |
    field_type_named
}
field_type_array = { field_type_base ~ "[]" }
field_type_object = { "{" ~ struct_body ~ "}" }
field_type_named = { identifier }
field_type_base = { "string" | "number" | "boolean" | identifier }

// === Output Type (for agent output field) ===
output_type = { field_type_object | identifier }

// === Block & Statements ===
block = { "{" ~ block_stmt* ~ "}" }
block_stmt = { let_stmt | return_stmt | if_stmt | for_stmt | while_stmt | try_stmt | break_stmt | continue_stmt | expr_stmt }
let_stmt = { "let" ~ identifier ~ "=" ~ expression }
return_stmt = { "return" ~ expression? }
if_stmt = { "if" ~ expression ~ block ~ ("else" ~ block)? }
for_stmt = { "for" ~ identifier ~ "in" ~ expression ~ block }
while_stmt = { "while" ~ expression ~ block }
try_stmt = { "try" ~ block ~ "catch" ~ identifier ~ block }
break_stmt = { "break" }
continue_stmt = { "continue" }
expr_stmt = { expression }

// === Agent Declaration ===
agent_decl = { "agent" ~ identifier ~ "{" ~ agent_body ~ "}" }
agent_body = { agent_item* }
agent_item = { use_stmt | output_field | agent_field }

// === Use Statement ===
// use_keyword is atomic to ensure "use" is a complete word (not prefix of "userPrompt")
use_keyword = @{ "use" ~ !ASCII_ALPHANUMERIC }
use_stmt = { use_keyword ~ identifier ~ ("," ~ identifier)* }

// === Agent Field ===
// output_field must come before agent_field since "output" would also match as identifier
output_field = { "output" ~ ":" ~ output_type }
agent_field = { identifier ~ ":" ~ expression }

// === Expressions (EXPANDED) ===
expression = { logical_or }
logical_or = { logical_and ~ ("||" ~ logical_and)* }
logical_and = { equality ~ ("&&" ~ equality)* }
equality = { comparison ~ (("==" | "!=") ~ comparison)* }
comparison = { additive ~ (("<=" | ">=" | "<" | ">") ~ additive)* }
additive = { multiplicative ~ (("+" | "-") ~ multiplicative)* }
multiplicative = { unary ~ (("*" | "/" | "%") ~ unary)* }
unary = { ("!" | "-")* ~ postfix }
postfix = { primary ~ (call_expr | index_expr | member_expr)* }

call_expr = { "(" ~ arg_list? ~ ")" }
arg_list = { expression ~ ("," ~ expression)* }
index_expr = { "[" ~ expression ~ "]" }
member_expr = { "." ~ identifier }

primary = {
    "(" ~ expression ~ ")" |
    array_literal |
    object_literal |
    null_literal |
    range_expr |
    string_literal |
    number_literal |
    boolean_literal |
    identifier
}

// === Range Expression ===
range_expr = { number_literal ~ ".." ~ number_literal }

// === New Literals ===
null_literal = { "null" }
array_literal = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }
object_literal = { "{" ~ (object_field ~ ("," ~ object_field)*)? ~ "}" }
object_field = { (identifier | string_literal) ~ ":" ~ expression }

// === Literals ===
// Multi-line strings use triple quotes """ and preserve newlines
multiline_string = ${ "\"\"\"" ~ multiline_part* ~ "\"\"\"" }
multiline_part = { multiline_interpolation | multiline_chars }
multiline_interpolation = !{ "{" ~ expression ~ "}" }
multiline_chars = @{ (!("\"\"\"" | "{") ~ ANY)+ }

// string_literal: multiline_string must come first since """ would otherwise match as "" + "
string_literal = ${ multiline_string | ("\"" ~ string_part* ~ "\"") }
string_part = { interpolation | string_chars }
interpolation = !{ "{" ~ expression ~ "}" }
string_chars = @{ (!(("\"" | "\\") | "{") ~ ANY | escape_sequence)+ }
escape_sequence = @{ "\\" ~ ("\"" | "\\" | "n" | "r" | "t" | "{" | "}") }

number_literal = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
boolean_literal = { "true" | "false" }

// === Identifiers ===
identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// === Whitespace & Comments ===
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }
