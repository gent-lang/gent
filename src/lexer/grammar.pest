// === Program Structure ===
program = { SOI ~ statement* ~ EOI }
statement = { import_stmt | interface_decl | struct_decl | enum_decl | fn_decl | tool_decl | agent_decl | parallel_decl | top_level_let | top_level_call }

// === Import Statement ===
import_stmt = { "import" ~ "{" ~ import_list ~ "}" ~ "from" ~ string_literal }
import_list = { identifier ~ ("," ~ identifier)* }

// === Top-Level Let ===
top_level_let = { "let" ~ identifier ~ "=" ~ expression }

// === Top-Level Call ===
top_level_call = { identifier ~ "(" ~ arg_list? ~ ")" }

// === Tool Declaration ===
tool_decl = {
    "tool" ~ identifier ~ "(" ~ param_list? ~ ")" ~ return_type? ~ block
}

// === Function Declaration (pure, no agent access) ===
fn_decl = {
    "fn" ~ identifier ~ "(" ~ param_list? ~ ")" ~ return_type? ~ block
}

param_list = { param ~ ("," ~ param)* }
param = { identifier ~ ":" ~ type_name }
return_type = { "->" ~ type_name }
type_name = { "string" | "number" | "boolean" | "object" | "array" | "any" }

// === Struct Declaration ===
struct_decl = {
    "struct" ~ identifier ~ implements_clause? ~ "{" ~ struct_body ~ "}"
}
implements_clause = { "implements" ~ identifier ~ ("," ~ identifier)* }
struct_body = { (struct_field ~ ","?)* }
struct_field = { identifier ~ ":" ~ field_type }
field_type = {
    field_type_array |
    field_type_object |
    field_type_named
}
field_type_array = { field_type_base ~ "[]" }
field_type_object = { "{" ~ struct_body ~ "}" }
field_type_named = { identifier }
field_type_base = { "string" | "number" | "boolean" | identifier }

// === Enum Declaration ===
enum_decl = { "enum" ~ identifier ~ "{" ~ enum_body ~ "}" }
enum_body = { (enum_variant ~ ","?)* }
enum_variant = { identifier ~ enum_variant_data? }
enum_variant_data = { "(" ~ enum_field_list ~ ")" }
enum_field_list = { enum_field ~ ("," ~ enum_field)* }
enum_field = { (identifier ~ ":")? ~ identifier }

// === Interface Declaration ===
interface_decl = { "interface" ~ identifier ~ "{" ~ interface_body ~ "}" }
interface_body = { interface_member* }
interface_member = { interface_method | interface_field }
interface_field = { identifier ~ ":" ~ type_name }
interface_method = { identifier ~ "(" ~ param_list? ~ ")" ~ return_type? }

// === Parallel Declaration ===
parallel_decl = { "parallel" ~ identifier ~ "{" ~ parallel_body ~ "}" }
parallel_body = { parallel_field* }
parallel_field = { agents_field | timeout_field }
agents_field = { "agents" ~ ":" ~ "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }
timeout_field = { "timeout" ~ ":" ~ duration_literal }

// === Output Type (for agent output field) ===
output_type = { field_type_object | identifier }

// === Block & Statements ===
block = { "{" ~ block_stmt* ~ "}" }
block_stmt = { let_stmt | assignment_stmt | return_stmt | if_stmt | for_stmt | while_stmt | try_stmt | break_stmt | continue_stmt | expr_stmt }
let_stmt = { "let" ~ identifier ~ "=" ~ expression }
assignment_stmt = { identifier ~ "=" ~ expression }
return_stmt = { "return" ~ expression? }
if_stmt = { "if" ~ expression ~ block ~ ("else" ~ block)? }
for_stmt = { "for" ~ identifier ~ "in" ~ expression ~ block }
while_stmt = { "while" ~ expression ~ block }
try_stmt = { "try" ~ block ~ "catch" ~ identifier ~ block }
break_stmt = { "break" }
continue_stmt = { "continue" }
expr_stmt = { expression }

// === Agent Declaration ===
agent_decl = { "agent" ~ identifier ~ "{" ~ agent_body ~ "}" }
agent_body = { agent_item* }
agent_item = { use_stmt | output_field | agent_field }

// === Use Statement ===
// use_keyword is atomic to ensure "use" is a complete word (not prefix of "userPrompt")
use_keyword = @{ "use" ~ !ASCII_ALPHANUMERIC }
use_stmt = { use_keyword ~ identifier ~ ("," ~ identifier)* }

// === Agent Field ===
// output_field must come before agent_field since "output" would also match as identifier
output_field = { "output" ~ ":" ~ output_type }
agent_field = { identifier ~ ":" ~ expression }

// === Expressions (EXPANDED) ===
expression = { logical_or }
logical_or = { logical_and ~ ("||" ~ logical_and)* }
logical_and = { equality ~ ("&&" ~ equality)* }
equality = { comparison ~ (("==" | "!=") ~ comparison)* }
comparison = { additive ~ (("<=" | ">=" | "<" | ">") ~ additive)* }
additive = { multiplicative ~ (("+" | "-") ~ multiplicative)* }
multiplicative = { unary ~ (("*" | "/" | "%") ~ unary)* }
unary = { ("!" | "-")* ~ postfix }
postfix = { primary ~ (call_expr | index_expr | member_expr)* }

call_expr = { "(" ~ arg_list? ~ ")" }
arg_list = { expression ~ ("," ~ expression)* }
index_expr = { "[" ~ expression ~ "]" }
member_expr = { "." ~ identifier }

primary = {
    match_expr |
    lambda |
    "(" ~ expression ~ ")" |
    array_literal |
    object_literal |
    null_literal |
    range_expr |
    string_literal |
    number_literal |
    boolean_literal |
    identifier
}

// === Match Expression ===
match_expr = { "match" ~ expression ~ "{" ~ match_arm* ~ "}" }
match_arm = { match_pattern ~ "=>" ~ match_arm_body ~ ","? }
match_pattern = { wildcard_pattern | enum_pattern }
wildcard_pattern = { "_" }
enum_pattern = { identifier ~ "." ~ identifier ~ ("(" ~ pattern_bindings? ~ ")")? }
pattern_bindings = { identifier ~ ("," ~ identifier)* }
match_arm_body = { block | expression }

// Lambda expression: (x) => x * 2 or (a, b) => a + b or () => 42
lambda = { "(" ~ lambda_params? ~ ")" ~ "=>" ~ lambda_body }
lambda_params = { identifier ~ ("," ~ identifier)* }
lambda_body = { block | expression }

// === Range Expression ===
range_expr = { number_literal ~ ".." ~ number_literal }

// === New Literals ===
null_literal = { "null" }
array_literal = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }
object_literal = { "{" ~ (object_field ~ ("," ~ object_field)*)? ~ "}" }
object_field = { (identifier | string_literal) ~ ":" ~ expression }

// === Literals ===
// Multi-line strings use triple quotes """ and preserve newlines
multiline_string = ${ "\"\"\"" ~ multiline_part* ~ "\"\"\"" }
multiline_part = { multiline_interpolation | multiline_chars }
multiline_interpolation = !{ "{" ~ expression ~ "}" }
multiline_chars = @{ (!("\"\"\"" | "{") ~ ANY)+ }

// string_literal: multiline_string must come first since """ would otherwise match as "" + "
string_literal = ${ multiline_string | ("\"" ~ string_part* ~ "\"") }
string_part = { interpolation | string_chars }
interpolation = !{ "{" ~ expression ~ "}" }
string_chars = @{ (!(("\"" | "\\") | "{") ~ ANY | escape_sequence)+ }
escape_sequence = @{ "\\" ~ ("\"" | "\\" | "n" | "r" | "t" | "{" | "}") }

number_literal = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }

// === Duration Literal ===
duration_literal = @{ ASCII_DIGIT+ ~ duration_unit }
duration_unit = { "ms" | "s" | "m" }

boolean_literal = { "true" | "false" }

// === Identifiers ===
identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// === Whitespace & Comments ===
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }
